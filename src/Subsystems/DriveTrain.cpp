// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "DriveTrain.h"
#include "../Util/PIDCanTalon.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/Drive.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

DriveTrain::DriveTrain() :
		Subsystem("DriveTrain") {

	CANTalonLeftFront = RobotMap::driveTrainCANTalonLeftFront;
	CANTalonLeftRear = RobotMap::driveTrainCANTalonLeftRear;
	CANTalonRightFront = RobotMap::driveTrainCANTalonRightFront;
	CANTalonRightRear = RobotMap::driveTrainCANTalonRightRear;
	robotDrive = RobotMap::driveTrainRobotDrive;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	driveGyro = RobotMap::driveTrainDriveGyro;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	//Need to reverse encoder direction for the right hand motors:
	CANTalonRightFront->SetSensorDirection(true);
	CANTalonRightRear->SetSensorDirection(true);
	CANTalonLeftFront->SetSensorDirection(true);
	CANTalonLeftRear->SetSensorDirection(true);

	CANTalonLeftFront->ConfigNeutralMode(CANTalon::kNeutralMode_Brake);
	CANTalonRightFront->ConfigNeutralMode(CANTalon::kNeutralMode_Brake);
	CANTalonLeftRear->ConfigNeutralMode(CANTalon::kNeutralMode_Brake);
	CANTalonRightRear->ConfigNeutralMode(CANTalon::kNeutralMode_Brake);
}
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Drive());

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

// Put methods for controlling this subsystem

void DriveTrain::drive(float x, float y, float z) {
	robotDrive->MecanumDrive_Cartesian(x, y, z);
}

void DriveTrain::ReadDashboardValues() {
	p = SmartDashboard::GetNumber(PROPORTIONAL_CONSTANT_DASHBOARD_KEY,
			PROPORTIONAL_CONSTANT_DEFAULT);
	i = SmartDashboard::GetNumber(INTEGRAL_CONSTANT_DAHSBOARD_KEY,
			INTEGRAL_CONSTANT_DEFAULT);
	maxpercent = SmartDashboard::GetNumber(MAX_PERCENT_DASHBOARD_KEY,
			MAX_PERCENT_DEFAULT);
	absolutetolerance = SmartDashboard::GetNumber(
			ABSOLUTE_TOLERANCE_DASHBOARD_KEY, ABSOLUTE_TOLERANCE_DEFAULT);
	leftFrontPIDController->SetOutputRange(-1 * maxpercent, maxpercent);
	rightFrontPIDController->SetOutputRange(-1 * maxpercent, maxpercent);
	leftRearPIDController->SetOutputRange(-1 * maxpercent, maxpercent);
	rightRearPIDController->SetOutputRange(-1 * maxpercent, maxpercent);
	leftFrontPIDController->SetAbsoluteTolerance(absolutetolerance);
	rightFrontPIDController->SetAbsoluteTolerance(absolutetolerance);
	leftRearPIDController->SetAbsoluteTolerance(absolutetolerance);
	rightRearPIDController->SetAbsoluteTolerance(absolutetolerance);

	leftFrontPIDController -> SetPID(p, i, 0);
	rightFrontPIDController -> SetPID(p, i, 0);
	leftRearPIDController -> SetPID(p, i, 0);
	rightRearPIDController -> SetPID(p, i, 0);


}

void DriveTrain::Init() {


	leftFrontPIDCanTalon = new PIDCanTalon(CANTalonLeftFront);
	Robot::driveTrain->CANTalonLeftFront->SetSensorDirection(true);
	leftFrontPIDController = new PIDController(0, 0, 0, leftFrontPIDCanTalon,
			Robot::driveTrain->CANTalonLeftFront);

	rightFrontPIDCanTalon = new PIDCanTalon(CANTalonRightFront);
	Robot::driveTrain->CANTalonRightFront->SetSensorDirection(true);
	rightFrontPIDController = new PIDController(0, 0, 0, rightFrontPIDCanTalon,
			Robot::driveTrain->CANTalonLeftFront);

	leftRearPIDCanTalon = new PIDCanTalon(CANTalonLeftRear);
	Robot::driveTrain->CANTalonLeftRear->SetSensorDirection(true);
	leftRearPIDController = new PIDController(0, 0, 0, leftRearPIDCanTalon,
			Robot::driveTrain->CANTalonLeftRear);

	rightRearPIDCanTalon = new PIDCanTalon(CANTalonRightRear);
	Robot::driveTrain->CANTalonRightRear->SetSensorDirection(true);
	rightRearPIDController = new PIDController(0, 0, 0, rightRearPIDCanTalon,
			Robot::driveTrain->CANTalonRightRear);

	ReadDashboardValues();

	SmartDashboard::PutNumber(CLOSED_LOOP_ERROR_LEFT_FRONT_DASHBOARD_KEY,
			Robot::driveTrain->leftFrontPIDController->GetError());
	SmartDashboard::PutNumber(ENCODER_POSITION_LEFT_FRONT_DASHBOARD_KEY,
			Robot::driveTrain->CANTalonLeftFront->GetEncPosition());

	SmartDashboard::PutNumber(CLOSED_LOOP_ERROR_LEFT_REAR_DASHBOARD_KEY,
			Robot::driveTrain->leftRearPIDController->GetError());
	SmartDashboard::PutNumber(ENCODER_POSITION_LEFT_REAR_DASHBOARD_KEY,
			Robot::driveTrain->CANTalonLeftRear->GetEncPosition());

	SmartDashboard::PutNumber(CLOSED_LOOP_ERROR_RIGHT_REAR_DASHBOARD_KEY,
			Robot::driveTrain->rightRearPIDController->GetError());
	SmartDashboard::PutNumber(ENCODER_POSITION_RIGHT_REAR_DASHBOARD_KEY,
			Robot::driveTrain->CANTalonRightRear->GetEncPosition());

	SmartDashboard::PutNumber(CLOSED_LOOP_ERROR_RIGHT_FRONT_DASHBOARD_KEY,
			Robot::driveTrain->rightFrontPIDController->GetError());
	SmartDashboard::PutNumber(ENCODER_POSITION_RIGHT_FRONT_DASHBOARD_KEY,
			Robot::driveTrain->CANTalonRightFront->GetEncPosition());
}

float DriveTrain::GetGyroRate() {
	return driveGyro->GetRate();
}

float DriveTrain::GetGyroAngle() {
	return driveGyro->GetAngle();
}

void DriveTrain::EncoderReset() {
	RobotMap::driveTrainCANTalonLeftFront->SetPosition(0);
	RobotMap::driveTrainCANTalonLeftRear->SetPosition(0);
	RobotMap::driveTrainCANTalonRightRear->SetPosition(0);
	RobotMap::driveTrainCANTalonRightFront->SetPosition(0);
}

void DriveTrain::ResetDistance() {
	RobotMap::driveTrainCANTalonLeftFront->SetPosition(0);
	RobotMap::driveTrainCANTalonLeftRear->SetPosition(0);
	RobotMap::driveTrainCANTalonRightRear->SetPosition(0);
	RobotMap::driveTrainCANTalonRightFront->SetPosition(0);
}

void DriveTrain::SetDistanceInFeet(int x) {

	TICKS_NEEDED = Robot::driveTrain->WHEELROTATIONS_PER_FOOT
			* Robot::driveTrain->ENCODER_TICKS_PER_REVOLUTION * x;
	SmartDashboard:: PutNumber (TICKS_NEEDED_DASHBOARD_KEY, TICKS_NEEDED_DEFAULT);
	leftRearPIDController->SetSetpoint(TICKS_NEEDED);
	rightRearPIDController->SetSetpoint(TICKS_NEEDED);
	leftFrontPIDController->SetSetpoint(TICKS_NEEDED);
	rightFrontPIDController->SetSetpoint(TICKS_NEEDED);
	leftFrontPIDController->Enable();
	rightFrontPIDController -> Enable();
	rightRearPIDController -> Enable();
	leftRearPIDController->Enable();
}

bool DriveTrain::AtDestination() {
	// return frontLeftPIDController->OnTarget();
	return (rightFrontPIDController -> OnTarget()
			&&leftFrontPIDController -> OnTarget()
			&& rightRearPIDController-> OnTarget()
			&& leftRearPIDController -> OnTarget());
}

void DriveTrain::DisablePIDControllers(){
	Robot:: driveTrain -> leftFrontPIDController->Disable();
	Robot:: driveTrain -> rightFrontPIDController->Disable();
	Robot:: driveTrain -> leftRearPIDController->Disable();
	Robot:: driveTrain -> rightRearPIDController->Disable();
}

// here. Call these from Commands.

